/// A trait that describes a
/// [`Newtype`](https://rust-unofficial.github.io/patterns/patterns/behavioural/newtype.html)
/// wrapper struct generated by [`define!`](crate::define) and
/// [`extend!`](crate::extend) macros.
pub trait Wrapper: Sized {
    /// An underlying type of the wrapper.
    type Inner;
    /// A type of an error that can occur during the construction or mutation
    /// of the wrapper's value.
    type Error;
    /// A function that will mutate and validate wrapper's inner value on
    /// every construction and mutation.
    ///
    /// It's behaviour is based on the closures that were provided during the
    /// invocation of [`define!`](crate::define)/[`extend!`](crate::extend)
    /// macros (e.g. `adjust`, `ensure` and `validate`).
    ///
    /// If no closures were provided, this function will not mutate the value
    /// and always return `Ok(())`.
    const PROCESS: fn(&mut Self::Inner) -> Result<(), Self::Error>;

    /// Construct a new wrapper.
    ///
    /// It will return an error if the provided `value` doesn't pass
    /// [`Self::PROCESS`](Self::PROCESS).
    fn new(value: impl Into<Self::Inner>) -> Result<Self, ConstructionError<Self>>;

    /// Get a shared reference to the inner value.
    fn get(&self) -> &Self::Inner;

    // TODO: maybe change `ConstructionError` to `ReplacementError`?
    /// Replace inner value with the provided one.
    ///
    /// It will return an error if the provided `value` doesn't pass
    /// [`Self::PROCESS`](Self::PROCESS).
    fn set(&mut self, value: impl Into<Self::Inner>) -> Result<(), ConstructionError<Self>>;

    /// Mutate inner value using provided closure.
    ///
    /// To make sure that the closure doesn't corrupt the inner value, this
    /// method is only available when the inner type implements
    /// [`Clone`](Clone). This way, the closure receives a copy of the inner
    /// value, and then, if the mutated value passes
    /// [`Self::PROCESS`](Self::PROCESS), it will replace the inner value.
    fn mutate(&mut self, f: impl FnOnce(&mut Self::Inner)) -> Result<(), MutationError<Self>>
    where
        Self::Inner: Clone;

    /// Construct a new wrapper without calling
    /// [`Self::PROCESS`](Self::PROCESS).
    #[cfg(feature = "unprocessed")]
    #[cfg_attr(docsrs, doc(cfg(feature = "unprocessed")))]
    fn new_unprocessed(value: impl Into<Self::Inner>) -> Self;

    /// Replace inner value with the provided one without calling
    /// [`Self::PROCESS`](Self::PROCESS).
    #[cfg(feature = "unprocessed")]
    #[cfg_attr(docsrs, doc(cfg(feature = "unprocessed")))]
    fn set_unprocessed(&mut self, value: impl Into<Self::Inner>);

    /// Mutate inner value using provided closure without calling
    /// [`Self::PROCESS`](Self::PROCESS).
    #[cfg(feature = "unprocessed")]
    #[cfg_attr(docsrs, doc(cfg(feature = "unprocessed")))]
    fn mutate_unprocessed(&mut self, f: impl FnOnce(&mut Self::Inner));

    /// Verify that inner value still passes [`Self::PROCESS`](Self::PROCESS).
    #[cfg(feature = "unprocessed")]
    #[cfg_attr(docsrs, doc(cfg(feature = "unprocessed")))]
    fn verify(self) -> Result<Self, VerificationError<Self>>;
}

#[derive(Debug)]
pub struct ConstructionError<W: Wrapper> {
    pub value: W::Inner,
    pub error: W::Error,
}

impl<W> fmt::Display for ConstructionError<W>
where
    W: Wrapper,
    W::Inner: fmt::Debug,
    W::Error: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "failed to construct type {} from value {:?}: {}",
            std::any::type_name::<W>(),
            self.value,
            self.error,
        )
    }
}

impl<W> Error for ConstructionError<W>
where
    W: Wrapper + fmt::Debug,
    W::Inner: fmt::Debug,
    W::Error: fmt::Display + fmt::Debug,
{
    // NOTE: `self.error` could be used for `source` function.
    // However, it would require `W::Error: Error + 'static`,
    // which is more restrictive, therefore less appealing.
    // It's also not clear for me if this change would be
    // useful.
    // Waiting for the stabilization of specialization?
}

#[derive(Debug)]
pub struct MutationError<W: Wrapper> {
    pub old_value: W::Inner,
    pub new_value: W::Inner,
    pub error: W::Error,
}

impl<W> fmt::Display for MutationError<W>
where
    W: Wrapper,
    W::Inner: fmt::Debug,
    W::Error: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "failed to mutate type {} from value {:?} to value {:?}: {}",
            std::any::type_name::<W>(),
            self.old_value,
            self.new_value,
            self.error,
        )
    }
}

impl<W> Error for MutationError<W>
where
    W: Wrapper + fmt::Debug,
    W::Inner: fmt::Debug,
    W::Error: fmt::Display + fmt::Debug,
{
}

#[derive(Debug)]
pub struct VerificationError<W: Wrapper> {
    pub value: W::Inner,
    pub error: W::Error,
}

impl<W> fmt::Display for VerificationError<W>
where
    W: Wrapper,
    W::Inner: fmt::Debug,
    W::Error: fmt::Display,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "verification of type {} with value {:?} failed: {}",
            std::any::type_name::<W>(),
            self.value,
            self.error,
        )
    }
}

impl<W> Error for VerificationError<W>
where
    W: Wrapper + fmt::Debug,
    W::Inner: fmt::Debug,
    W::Error: fmt::Display + fmt::Debug,
{
}

// #[cfg(feature = "serde")]
// impl<'de, T, B> serde::Deserialize<'de> for Bounded<T, B>
// where
//     T: serde::Deserialize<'de> + std::fmt::Debug,
//     B: Bound<Target = T> + fmt::Debug,
//     B::Error: std::fmt::Display + std::fmt::Debug,
// {
//     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
//     where
//         D: serde::Deserializer<'de>,
//     {
//         Self::new(B::Target::deserialize(deserializer)?)
//             .map_err(|e| serde::de::Error::custom(e.inner))
//     }
// }
//
// #[cfg(feature = "serde")]
// impl<T, B> serde::Serialize for Bounded<T, B>
// where
//     T: serde::Serialize,
//     B: Bound<Target = T>,
//     B::Error: std::fmt::Display + std::fmt::Debug,
// {
//     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
//     where
//         S: serde::Serializer,
//     {
//         B::Target::serialize(self.get(), serializer)
//     }
// }

use std::error::Error;
use std::fmt;
